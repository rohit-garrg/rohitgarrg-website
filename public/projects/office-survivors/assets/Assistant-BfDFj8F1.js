import{P as d,C as n,T as l,D as T}from"./index--jhV1Xr-.js";const c={WANDER:"WANDER",FETCHING:"FETCHING",DELIVERING:"DELIVERING"},y=(()=>{const i=n.TILE_SIZE,t=i/2;return{CEO:{approach:{x:9*i+t,y:3*i+i},entry:{x:5*i+t,y:3*i+i}},MARKETING:{approach:{x:9*i+t,y:9*i+i},entry:{x:5*i+t,y:9*i+i}},ENGINEERING:{approach:{x:9*i+t,y:19*i+i},entry:{x:5*i+t,y:19*i+i}},FINANCE:{approach:{x:30*i+t,y:9*i+i},entry:{x:34*i+t,y:9*i+i}},HR:{approach:{x:30*i+t,y:19*i+i},entry:{x:34*i+t,y:19*i+i}}}})();class u extends d.GameObjects.Sprite{constructor(t,s,e){const a=t.textures.exists("agent-assistant")?"agent-assistant":"assistant";super(t,s,e,a,0),console.log("[Assistant] initialized"),this._animPrefix=t.textures.exists("agent-assistant")?"assistant":null,this._facing="south",this.deliveryInterval=n.ASSISTANT_DELIVERY_INTERVAL,this._deliveryTimer=0,this.isActive=!1,this._state=c.WANDER,this._wanderTarget=null,this._speed=n.ASSISTANT_SPEED,this._targetTask=null,this._deliveryDeptId=null,this._waypoints=[],this._waypointIdx=0,this._actionTimer=0,this._stuckTimer=0,this._lastPos={x:0,y:0}}activate(t,s){this.setPosition(t,s),this.setActive(!0),this.setVisible(!0),this.setDepth(9),this.isActive=!0,this._deliveryTimer=0,this._state=c.WANDER,this._targetTask=null,this._deliveryDeptId=null,this._waypoints=[],this._waypointIdx=0,this._actionTimer=0,this._stuckTimer=0,this._lastPos={x:t,y:s},this.body&&(this.body.setSize(20,20),this.body.setOffset(6,10)),this._facing="south",this.updateAssistantAnimation(0,0),this.pickNewWanderTarget()}deactivate(){this.isActive=!1,this._state=c.WANDER,this._targetTask=null,this._deliveryDeptId=null,this._waypoints=[],this.setActive(!1),this.setVisible(!1),this.body&&this.body.setVelocity(0,0)}update(t,s){if(this.isActive)switch(this._stuckTimer+=s,this._stuckTimer>=n.ASSISTANT_STUCK_CHECK_INTERVAL&&(d.Math.Distance.Between(this.x,this.y,this._lastPos.x,this._lastPos.y)<n.ASSISTANT_STUCK_MOVE_THRESHOLD&&this.handleStuck(),this._lastPos={x:this.x,y:this.y},this._stuckTimer=0),this._state){case c.WANDER:this.updateWander(s);break;case c.FETCHING:this.updateFetching(s);break;case c.DELIVERING:this.updateDelivering(s);break}}updateWander(t){this.moveToward(this._wanderTarget),this._wanderTarget&&d.Math.Distance.Between(this.x,this.y,this._wanderTarget.x,this._wanderTarget.y)<n.ASSISTANT_WANDER_ARRIVAL_RANGE&&this.pickNewWanderTarget(),this._deliveryTimer+=t,this._deliveryTimer>=n.ASSISTANT_SEEK_DELAY&&(this._deliveryTimer=0,this.seekTask())}pickNewWanderTarget(){const t=n.MAP_WIDTH_TILES*n.TILE_SIZE,s=n.MAP_HEIGHT_TILES*n.TILE_SIZE,e=n.TILE_SIZE*3;this._wanderTarget={x:e+Math.random()*(t-e*2),y:e+Math.random()*(s-e*2)}}seekTask(){const t=this.scene.taskManager;if(!t)return;const s=t.getActiveTasks();let e=null,a=1/0,h=!1;for(const r of s){if(r.state!==l.SPAWNED||r.isDecoy)continue;const o=d.Math.Distance.Between(this.x,this.y,r.x,r.y),_=r.totalStops===1;(!e||_&&!h||_===h&&o<a)&&(e=r,a=o,h=_)}e?(this._targetTask=e,this._state=c.FETCHING,this._actionTimer=0,console.debug(`[Assistant] seeking task: "${e.taskName}" (${Math.round(a)}px away)`)):console.debug("[Assistant] no tasks on map to fetch")}updateFetching(t){const s=this._targetTask;if(this._actionTimer+=t,this._actionTimer>=n.ASSISTANT_FETCH_TIMEOUT){console.debug("[Assistant] fetch timeout, returning to wander"),this.resetToWander();return}if(!s||s.state!==l.SPAWNED){console.debug("[Assistant] target task gone, returning to wander"),this.resetToWander();return}this.moveToward({x:s.x,y:s.y}),d.Math.Distance.Between(this.x,this.y,s.x,s.y)<=n.ASSISTANT_PICKUP_RANGE&&this.pickUpTask()}pickUpTask(){const t=this._targetTask,s=this.scene.taskManager;if(!t||!s){this.resetToWander();return}let e;t.route&&t.route.length>0?e=t.route[t.route.length-1]:e=t.department,this._deliveryDeptId=e;const a=s.activeTasks.indexOf(t);a!==-1&&s.activeTasks.splice(a,1),t.setVisible(!1),t.setActive(!1),t.body&&(t.body.enable=!1);const h=y[e];if(h)this._waypoints=[{x:h.approach.x,y:h.approach.y},{x:h.entry.x,y:h.entry.y}];else{const r=T.find(o=>o.id===e);if(r){const o=n.TILE_SIZE;this._waypoints=[{x:r.position.x*o+r.size.width*o/2,y:r.position.y*o+r.size.height*o/2}]}else{console.warn(`[Assistant] unknown department "${e}", force-delivering`),this.completeDelivery();return}}this._waypointIdx=0,this._actionTimer=0,this._state=c.DELIVERING,console.debug(`[Assistant] picked up "${t.taskName}", delivering to ${e} (${this._waypoints.length} waypoints)`)}updateDelivering(t){if(!this._targetTask||this._waypoints.length===0){this.resetToWander();return}if(this._actionTimer+=t,this._actionTimer>=n.ASSISTANT_DELIVER_TIMEOUT){console.debug("[Assistant] delivery timeout, force-completing"),this.completeDelivery();return}const s=this._waypoints[this._waypointIdx];this.moveToward(s),d.Math.Distance.Between(this.x,this.y,s.x,s.y)<=n.ASSISTANT_WAYPOINT_RANGE&&(this._waypointIdx++,this._waypointIdx>=this._waypoints.length&&this.completeDelivery())}completeDelivery(){const t=this._targetTask,s=this.scene.taskManager,e=this._deliveryDeptId;if(!t||!s){this.resetToWander();return}const a=t.taskName,h=s.calculateXP(t,e),r=s.getStressRelief(t,e);s.tasksDelivered++;const o=s.deliveryCounts.get(e)||0;s.deliveryCounts.set(e,o+1),t.currentStop=t.totalStops,t.state=l.DONE,this.scene.events.emit("task-delivered",{task:t,department:e,xp:h,stressRelief:r}),t.deactivate(),console.log(`[Assistant] delivered "${a}" to ${e} +${h}XP -${r}%stress`),this.resetToWander()}moveToward(t){if(!t||!this.body)return;const s=d.Math.Angle.Between(this.x,this.y,t.x,t.y),e=Math.cos(s)*this._speed,a=Math.sin(s)*this._speed;this.body.setVelocity(e,a),this.updateAssistantAnimation(e,a)}handleStuck(){if(this._state===c.WANDER)this.pickNewWanderTarget();else{const t=Math.random()*Math.PI*2;this.body&&this.body.setVelocity(Math.cos(t)*this._speed*1.5,Math.sin(t)*this._speed*1.5)}}resetToWander(){this._targetTask=null,this._deliveryDeptId=null,this._waypoints=[],this._waypointIdx=0,this._actionTimer=0,this._state=c.WANDER,this.pickNewWanderTarget()}updateAssistantAnimation(t,s){var h;if(!this._animPrefix)return;const e=Math.abs(t)>.1||Math.abs(s)>.1;e&&(Math.abs(t)>Math.abs(s)?this._facing=t>0?"east":"west":this._facing=s>0?"south":"north");const a=e?`${this._animPrefix}-walk-${this._facing}`:`${this._animPrefix}-idle-${this._facing}`;((h=this.anims.currentAnim)==null?void 0:h.key)!==a&&this.scene.anims.exists(a)&&this.play(a,!0)}}export{u as Assistant};
